<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>File: README</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href=".././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



  <div id="fileHeader">
    <h1>README</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>README
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sat Mar 24 02:19:46 -0500 2007</td>
    </tr>
    </table>
  </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <h1><a href="../classes/GemPlugin.html">GemPlugin</a>: Gem Based Plugin System</h1>
<p>
<a href="../classes/GemPlugin.html">GemPlugin</a> is a system that lets
your users install gems and lets you load them as additional features to
use in your software. It originated from the Mongrel (<a
href="http://mongrel.rubyforge.org">mongrel.rubyforge.org</a>) project but
proved useful enough to break out into a separate project.
</p>
<p>
<a href="../classes/GemPlugin.html">GemPlugin</a> works by listing the gems
installed, and doing a require_gem on any that have the right dependencies.
For example, if a gem depends on &quot;gem_plugin&quot; and
&quot;mongrel&quot; then it&#8216;ll load as a Mongrel plugin. This makes
it so that users of the plugins only need to gem install (and maybe config
a bit), and plugin authors only need to make gems.
</p>
<h2>Implementers</h2>
<p>
To use <a href="../classes/GemPlugin.html">GemPlugin</a> in your system you
only have to require &#8216;gem_plugin&#8217; and then use the
GemPlugin::Manager.create, GemPlugin::Manager.load, and
GemPlugin::Manager.available methods to work with them.
</p>
<ul>
<li>GemPlugin::Manager.load &#8212; Takes a &quot;depend include/exclude
map&quot; and loads plugins based on it.

</li>
<li>GemPlugin::Manager.create &#8212; Takes a URI style name and some options
then creates one for you.

</li>
<li>GemPlugin::Manager.available &#8212; Lets you inspect and mess with the
internal plugin registry.

</li>
</ul>
<h3>Loading Plugins</h3>
<p>
As an example from Mongrel it&#8216;s necessary to load plugins that depend
on rails after the Rails system is configured, but load other plugins right
when Mongrel is ready. To do this we very first do:
</p>
<pre>
 GemPlugin::Manager.instance.load &quot;mongrel&quot; =&gt; GemPlugin::INCLUDE, &quot;rails&quot; =&gt; GemPlugin::EXCLUDE
</pre>
<p>
Later, when it&#8216;s ready to load Rails plugins as well we do this:
</p>
<pre>
 GemPlugin::Manager.instance.load &quot;mongrel&quot; =&gt; GemPlugin::INCLUDE
</pre>
<p>
This simply loads any plugins that remain and are ready for use in Rails.
</p>
<h3>Creating Plugins</h3>
<p>
Creating a plugin is cake:
</p>
<pre>
 plug = GemPlugin::Manager.instance.create(&quot;/commands/snazzy&quot;, &quot;something&quot; =&gt; &quot;yeah&quot;)
</pre>
<p>
In this case we&#8216;re making the snazzy command and passing a couple
fake options.
</p>
<h3>Finding Available Plugins</h3>
<p>
Finding plugins is also very easy, you just call
GemPlugin::Manager.instance.available and you get a Hash that maps
categories to name =&gt; class. For example, if I had the
&quot;/commands/snazzy&quot; plugin registered above, then I&#8216;d get
the following:
</p>
<pre>
 puts GemPlugin::Manager.instance.available[&quot;/commands&quot;].inspect
 -&gt; { &quot;/snazzy&quot; =&gt; Snazzy}
</pre>
<h3>Plugins Inside Modules</h3>
<p>
Plugins that are placed in modules are also lowercased when registered but
still retain their module. So, if Snazzy was actually MyModule::Snazzy,
then it&#8216;d be registered as &quot;/commands/mymodule::snazzy&quot;.
</p>
<h2>Plugin Authors</h2>
<p>
People who wish to write gem plugins have a faily easy time of it, but need
to know the particular rules for the target system. To keep this example
concrete we&#8216;ll assume you want to write a Mongrel command plugin.
</p>
<p>
First thing is create your project like normal and setup Rake to make your
gem. Your plugin then needs to be created like so:
</p>
<pre>
 class Snazzy &lt; GemPlugin::Plugin &quot;/commands&quot;
    ...
 end
</pre>
<p>
And place this code in a file you will have RubyGems autorequire (I use
lib/init.rb).
</p>
<p>
Next you need to add the following to whatever Rakefile code you use to
create your gem:
</p>
<pre>
 spec.add_dependency('gem_plugin', '&gt;= 0.1')
 spec.add_dependency('mongrel', '&gt;= 0.3.9')
 spec.autorequire = 'init.rb'
</pre>
<p>
This does three things:
</p>
<ul>
<li>Tells GemPlugins::Manager.load that this is a <a
href="../classes/GemPlugin.html">GemPlugin</a>.

</li>
<li>Tells Mongrel that this is a Mongrel specific <a
href="../classes/GemPlugin.html">GemPlugin</a>.

</li>
<li>Tells RubyGems to run init.rb when the gem is required, just hooking up
your plugin.

</li>
</ul>
<p>
Now, all the users of your plugin have to do is gem install it and then
they get the plugin automagically.
</p>
<p>
People writing GemPlugins for other systems would have to check the
documentation from that project to get an idea of what extra requirements
might be needed. For example, you&#8216;d probably have to depend on
another project other that <b>mongrel</b> and most likely have a few more
things to configure in your init.rb.
</p>
<h2>Plugin Users</h2>
<p>
Plugin users have it the easiest of all. They simply do:
</p>
<pre>
 gem install mongrel_command_snazzy
</pre>
<p>
And that&#8216;s it. When they run mongrel_rails (given the above example)
this snazzy command get loaded automatically without any intervention.
</p>
<p>
The only thing missing in this release is a way for end users to configure
such a plugin. I really think this is the job of the implementers to
define.
</p>
<h2>Contact</h2>
<p>
E-mail zedshaw at zedshaw.com and I&#8216;ll help. Comments about the API
are welcome.
</p>

    </div>


   </div>


  </div>


    <!-- if includes -->

    <div id="section">





      


    <!-- if method_list -->


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>