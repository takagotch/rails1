--- !ruby/object:RI::MethodDescription 
aliases: []

block_params: 
comment: 
- !ruby/struct:SM::Flow::P 
  body: This will pop up an interactive ruby session at a pre-defined break point in a Ruby application. In this session you can examine the environment of the break point.
- !ruby/struct:SM::Flow::P 
  body: You can get a list of variables in the context using local_variables via <tt>local_variables</tt>. You can then examine their values by typing their names.
- !ruby/struct:SM::Flow::P 
  body: You can have a look at the call stack via <tt>caller</tt>.
- !ruby/struct:SM::Flow::P 
  body: The source code around the location where the breakpoint was executed can be examined via <tt>source_lines</tt>. Its argument specifies how much lines of context to display. The default amount of context is 5 lines. Note that the call to <tt>source_lines</tt> can raise an exception when it isn't able to read in the source code.
- !ruby/struct:SM::Flow::P 
  body: breakpoints can also return a value. They will execute a supplied block for getting a default return value. A custom value can be returned from the session by doing +throw(:debug_return, value)+.
- !ruby/struct:SM::Flow::P 
  body: You can also give names to break points which will be used in the message that is displayed upon execution of them.
- !ruby/struct:SM::Flow::P 
  body: "Here's a sample of how breakpoints should be placed:"
- !ruby/struct:SM::Flow::VERB 
  body: "  class Person\n    def initialize(name, age)\n      @name, @age = name, age\n      breakpoint(&quot;Person#initialize&quot;)\n    end\n\n    attr_reader :age\n    def name\n      breakpoint(&quot;Person#name&quot;) { @name }\n    end\n  end\n\n  person = Person.new(&quot;Random Person&quot;, 23)\n  puts &quot;Name: #{person.name}&quot;\n"
- !ruby/struct:SM::Flow::P 
  body: "And here is a sample debug session:"
- !ruby/struct:SM::Flow::VERB 
  body: "  Executing break point &quot;Person#initialize&quot; at file.rb:4 in `initialize'\n  irb(#&lt;Person:0x292fbe8&gt;):001:0&gt; local_variables\n  =&gt; [&quot;name&quot;, &quot;age&quot;, &quot;_&quot;, &quot;__&quot;]\n  irb(#&lt;Person:0x292fbe8&gt;):002:0&gt; [name, age]\n  =&gt; [&quot;Random Person&quot;, 23]\n  irb(#&lt;Person:0x292fbe8&gt;):003:0&gt; [@name, @age]\n  =&gt; [&quot;Random Person&quot;, 23]\n  irb(#&lt;Person:0x292fbe8&gt;):004:0&gt; self\n  =&gt; #&lt;Person:0x292fbe8 @age=23, @name=&quot;Random Person&quot;&gt;\n  irb(#&lt;Person:0x292fbe8&gt;):005:0&gt; @age += 1; self\n  =&gt; #&lt;Person:0x292fbe8 @age=24, @name=&quot;Random Person&quot;&gt;\n  irb(#&lt;Person:0x292fbe8&gt;):006:0&gt; exit\n  Executing break point &quot;Person#name&quot; at file.rb:9 in `name'\n  irb(#&lt;Person:0x292fbe8&gt;):001:0&gt; throw(:debug_return, &quot;Overriden name&quot;)\n  Name: Overriden name\n"
- !ruby/struct:SM::Flow::P 
  body: Breakpoint sessions will automatically have a few convenience methods available. See Breakpoint::CommandBundle for a list of them.
- !ruby/struct:SM::Flow::P 
  body: Breakpoints can also be used remotely over sockets. This is implemented by running part of the IRB session in the application and part of it in a special client. You have to call Breakpoint.activate_drb to enable support for remote breakpoints and then run breakpoint_client.rb which is distributed with this library. See the documentation of Breakpoint.activate_drb for details.
full_name: Breakpoint#breakpoint
is_singleton: false
name: breakpoint
params: (id = nil, context = nil, &block)
visibility: public
