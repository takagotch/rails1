--- !ruby/object:RI::MethodDescription 
aliases: []

block_params: (result)
comment: 
- !ruby/struct:SM::Flow::P 
  body: This method returns the binding of the method that called your method. It will raise an Exception when you're not inside a method.
- !ruby/struct:SM::Flow::P 
  body: "It's used like this:"
- !ruby/struct:SM::Flow::VERB 
  body: "  def inc_counter(amount = 1)\n    Binding.of_caller do |binding|\n      # Create a lambda that will increase the variable 'counter'\n      # in the caller of this method when called.\n      inc = eval(&quot;lambda { |arg| counter += arg }&quot;, binding)\n      # We can refer to amount from inside this block safely.\n      inc.call(amount)\n    end\n    # No other statements can go here. Put them inside the block.\n  end\n  counter = 0\n  2.times { inc_counter }\n  counter # =&gt; 2\n"
- !ruby/struct:SM::Flow::P 
  body: Binding.of_caller must be the last statement in the method. This means that you will have to put everything you want to do after the call to Binding.of_caller into the block of it. This should be no problem however, because Ruby has closures. If you don't do this an Exception will be raised. Because of the way that Binding.of_caller is implemented it has to be done this way.
full_name: Binding::of_caller
is_singleton: true
name: of_caller
params: (&block) {|result| ...}
visibility: public
