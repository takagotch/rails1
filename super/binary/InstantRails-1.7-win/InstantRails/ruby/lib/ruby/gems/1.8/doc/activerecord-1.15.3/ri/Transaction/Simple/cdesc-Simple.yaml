--- !ruby/object:RI::ClassDescription 
attributes: []

class_methods: 
- !ruby/object:RI::MethodSummary 
  name: debug_io
- !ruby/object:RI::MethodSummary 
  name: debug_io=
- !ruby/object:RI::MethodSummary 
  name: debugging?
- !ruby/object:RI::MethodSummary 
  name: start
- !ruby/object:RI::MethodSummary 
  name: start_named
comment: 
- !ruby/struct:SM::Flow::H 
  level: 1
  text: Transaction::Simple for Ruby
- !ruby/struct:SM::Flow::P 
  body: Simple object transaction support for Ruby
- !ruby/struct:SM::Flow::H 
  level: 2
  text: Introduction
- !ruby/struct:SM::Flow::P 
  body: Transaction::Simple provides a generic way to add active transaction support to objects. The transaction methods added by this module will work with most objects, excluding those that cannot be <em>Marshal</em>ed (bindings, procedure objects, IO instances, or singleton objects).
- !ruby/struct:SM::Flow::P 
  body: The transactions supported by Transaction::Simple are not backed transactions; they are not associated with any sort of data store. They are &quot;live&quot; transactions occurring in memory and in the object itself. This is to allow &quot;test&quot; changes to be made to an object before making the changes permanent.
- !ruby/struct:SM::Flow::P 
  body: Transaction::Simple can handle an &quot;infinite&quot; number of transaction levels (limited only by memory). If I open two transactions, commit the second, but abort the first, the object will revert to the original version.
- !ruby/struct:SM::Flow::P 
  body: Transaction::Simple supports &quot;named&quot; transactions, so that multiple levels of transactions can be committed, aborted, or rewound by referring to the appropriate name of the transaction. Names may be any object <b>except</b> <tt>nil</tt>. As with Hash keys, String names will be duplicated and frozen before using.
- !ruby/object:SM::Flow::LIST 
  contents: 
  - !ruby/struct:SM::Flow::LI 
    label: "Copyright:"
    body: "Copyright \xA9 2003 - 2005 by Austin Ziegler"
  - !ruby/struct:SM::Flow::LI 
    label: "Version:"
    body: 1.3.0
  - !ruby/struct:SM::Flow::LI 
    label: "Licence:"
    body: MIT-Style
  type: :NOTE
- !ruby/struct:SM::Flow::P 
  body: Thanks to David Black for help with the initial concept that led to this library.
- !ruby/struct:SM::Flow::H 
  level: 2
  text: Usage
- !ruby/struct:SM::Flow::VERB 
  body: "  include 'transaction/simple'\n\n  v = &quot;Hello, you.&quot;               # -&gt; &quot;Hello, you.&quot;\n  v.extend(Transaction::Simple)   # -&gt; &quot;Hello, you.&quot;\n\n  v.start_transaction             # -&gt; ... (a Marshal string)\n  v.transaction_open?             # -&gt; true\n  v.gsub!(/you/, &quot;world&quot;)         # -&gt; &quot;Hello, world.&quot;\n\n  v.rewind_transaction            # -&gt; &quot;Hello, you.&quot;\n  v.transaction_open?             # -&gt; true\n\n  v.gsub!(/you/, &quot;HAL&quot;)           # -&gt; &quot;Hello, HAL.&quot;\n  v.abort_transaction             # -&gt; &quot;Hello, you.&quot;\n  v.transaction_open?             # -&gt; false\n\n  v.start_transaction             # -&gt; ... (a Marshal string)\n  v.start_transaction             # -&gt; ... (a Marshal string)\n\n  v.transaction_open?             # -&gt; true\n  v.gsub!(/you/, &quot;HAL&quot;)           # -&gt; &quot;Hello, HAL.&quot;\n\n  v.commit_transaction            # -&gt; &quot;Hello, HAL.&quot;\n  v.transaction_open?             # -&gt; true\n  v.abort_transaction             # -&gt; &quot;Hello, you.&quot;\n  v.transaction_open?             # -&gt; false\n"
- !ruby/struct:SM::Flow::H 
  level: 2
  text: Named Transaction Usage
- !ruby/struct:SM::Flow::VERB 
  body: "  v = &quot;Hello, you.&quot;               # -&gt; &quot;Hello, you.&quot;\n  v.extend(Transaction::Simple)   # -&gt; &quot;Hello, you.&quot;\n\n  v.start_transaction(:first)     # -&gt; ... (a Marshal string)\n  v.transaction_open?             # -&gt; true\n  v.transaction_open?(:first)     # -&gt; true\n  v.transaction_open?(:second)    # -&gt; false\n  v.gsub!(/you/, &quot;world&quot;)         # -&gt; &quot;Hello, world.&quot;\n\n  v.start_transaction(:second)    # -&gt; ... (a Marshal string)\n  v.gsub!(/world/, &quot;HAL&quot;)         # -&gt; &quot;Hello, HAL.&quot;\n  v.rewind_transaction(:first)    # -&gt; &quot;Hello, you.&quot;\n  v.transaction_open?             # -&gt; true\n  v.transaction_open?(:first)     # -&gt; true\n  v.transaction_open?(:second)    # -&gt; false\n\n  v.gsub!(/you/, &quot;world&quot;)         # -&gt; &quot;Hello, world.&quot;\n  v.start_transaction(:second)    # -&gt; ... (a Marshal string)\n  v.gsub!(/world/, &quot;HAL&quot;)         # -&gt; &quot;Hello, HAL.&quot;\n  v.transaction_name              # -&gt; :second\n  v.abort_transaction(:first)     # -&gt; &quot;Hello, you.&quot;\n  v.transaction_open?             # -&gt; false\n\n  v.start_transaction(:first)     # -&gt; ... (a Marshal string)\n  v.gsub!(/you/, &quot;world&quot;)         # -&gt; &quot;Hello, world.&quot;\n  v.start_transaction(:second)    # -&gt; ... (a Marshal string)\n  v.gsub!(/world/, &quot;HAL&quot;)         # -&gt; &quot;Hello, HAL.&quot;\n\n  v.commit_transaction(:first)    # -&gt; &quot;Hello, HAL.&quot;\n  v.transaction_open?             # -&gt; false\n"
- !ruby/struct:SM::Flow::H 
  level: 2
  text: Block Usage
- !ruby/struct:SM::Flow::VERB 
  body: "  v = &quot;Hello, you.&quot;               # -&gt; &quot;Hello, you.&quot;\n  Transaction::Simple.start(v) do |tv|\n      # v has been extended with Transaction::Simple and an unnamed\n      # transaction has been started.\n    tv.transaction_open?          # -&gt; true\n    tv.gsub!(/you/, &quot;world&quot;)      # -&gt; &quot;Hello, world.&quot;\n\n    tv.rewind_transaction         # -&gt; &quot;Hello, you.&quot;\n    tv.transaction_open?          # -&gt; true\n\n    tv.gsub!(/you/, &quot;HAL&quot;)        # -&gt; &quot;Hello, HAL.&quot;\n      # The following breaks out of the transaction block after\n      # aborting the transaction.\n    tv.abort_transaction          # -&gt; &quot;Hello, you.&quot;\n  end\n    # v still has Transaction::Simple applied from here on out.\n  v.transaction_open?             # -&gt; false\n\n  Transaction::Simple.start(v) do |tv|\n    tv.start_transaction          # -&gt; ... (a Marshal string)\n\n    tv.transaction_open?          # -&gt; true\n    tv.gsub!(/you/, &quot;HAL&quot;)        # -&gt; &quot;Hello, HAL.&quot;\n\n      # If #commit_transaction were called without having started a\n      # second transaction, then it would break out of the transaction\n      # block after committing the transaction.\n    tv.commit_transaction         # -&gt; &quot;Hello, HAL.&quot;\n    tv.transaction_open?          # -&gt; true\n    tv.abort_transaction          # -&gt; &quot;Hello, you.&quot;\n  end\n  v.transaction_open?             # -&gt; false\n"
- !ruby/struct:SM::Flow::H 
  level: 2
  text: Named Transaction Usage
- !ruby/struct:SM::Flow::VERB 
  body: "  v = &quot;Hello, you.&quot;               # -&gt; &quot;Hello, you.&quot;\n  v.extend(Transaction::Simple)   # -&gt; &quot;Hello, you.&quot;\n\n  v.start_transaction(:first)     # -&gt; ... (a Marshal string)\n  v.transaction_open?             # -&gt; true\n  v.transaction_open?(:first)     # -&gt; true\n  v.transaction_open?(:second)    # -&gt; false\n  v.gsub!(/you/, &quot;world&quot;)         # -&gt; &quot;Hello, world.&quot;\n\n  v.start_transaction(:second)    # -&gt; ... (a Marshal string)\n  v.gsub!(/world/, &quot;HAL&quot;)         # -&gt; &quot;Hello, HAL.&quot;\n  v.rewind_transaction(:first)    # -&gt; &quot;Hello, you.&quot;\n  v.transaction_open?             # -&gt; true\n  v.transaction_open?(:first)     # -&gt; true\n  v.transaction_open?(:second)    # -&gt; false\n\n  v.gsub!(/you/, &quot;world&quot;)         # -&gt; &quot;Hello, world.&quot;\n  v.start_transaction(:second)    # -&gt; ... (a Marshal string)\n  v.gsub!(/world/, &quot;HAL&quot;)         # -&gt; &quot;Hello, HAL.&quot;\n  v.transaction_name              # -&gt; :second\n  v.abort_transaction(:first)     # -&gt; &quot;Hello, you.&quot;\n  v.transaction_open?             # -&gt; false\n\n  v.start_transaction(:first)     # -&gt; ... (a Marshal string)\n  v.gsub!(/you/, &quot;world&quot;)         # -&gt; &quot;Hello, world.&quot;\n  v.start_transaction(:second)    # -&gt; ... (a Marshal string)\n  v.gsub!(/world/, &quot;HAL&quot;)         # -&gt; &quot;Hello, HAL.&quot;\n\n  v.commit_transaction(:first)    # -&gt; &quot;Hello, HAL.&quot;\n  v.transaction_open?             # -&gt; false\n"
- !ruby/struct:SM::Flow::H 
  level: 2
  text: Thread Safety
- !ruby/struct:SM::Flow::P 
  body: Threadsafe version of Transaction::Simple and Transaction::Simple::Group exist; these are loaded from 'transaction/simple/threadsafe' and 'transaction/simple/threadsafe/group', respectively, and are represented in Ruby code as Transaction::Simple::ThreadSafe and Transaction::Simple::ThreadSafe::Group, respectively.
- !ruby/struct:SM::Flow::H 
  level: 2
  text: Contraindications
- !ruby/struct:SM::Flow::P 
  body: "While Transaction::Simple is very useful, it has some severe limitations that must be understood. Transaction::Simple:"
- !ruby/object:SM::Flow::LIST 
  contents: 
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: uses Marshal. Thus, any object which cannot be <em>Marshal</em>ed cannot use Transaction::Simple. In my experience, this affects singleton objects more often than any other object. It may be that Ruby 2.0 will solve this problem.
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: does not manage resources. Resources external to the object and its instance variables are not managed at all. However, all instance variables and objects &quot;belonging&quot; to those instance variables are managed. If there are object reference counts to be handled, Transaction::Simple will probably cause problems.
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: is not inherently thread-safe. In the ACID (&quot;atomic, consistent, isolated, durable&quot;) test, Transaction::Simple provides CD, but it is up to the user of Transaction::Simple to provide isolation and atomicity. Transactions should be considered &quot;critical sections&quot; in multi-threaded applications. If thread safety and atomicity is absolutely required, use Transaction::Simple::ThreadSafe, which uses a Mutex object to synchronize the accesses on the object during the transaction operations.
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: "does not necessarily maintain Object#<em>id</em> values on rewind or abort. This may change for future versions that will be Ruby 1.8 or better <b>only</b>. Certain objects that support #replace will maintain Object#<em>id</em>."
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: Can be a memory hog if you use many levels of transactions on many objects.
  type: :BULLET
constants: 
- !ruby/object:RI::Constant 
  comment: 
  name: TRANSACTION_SIMPLE_VERSION
  value: "'1.3.0'"
full_name: Transaction::Simple
includes: []

instance_methods: 
- !ruby/object:RI::MethodSummary 
  name: abort_transaction
- !ruby/object:RI::MethodSummary 
  name: commit_transaction
- !ruby/object:RI::MethodSummary 
  name: rewind_transaction
- !ruby/object:RI::MethodSummary 
  name: start_transaction
- !ruby/object:RI::MethodSummary 
  name: transaction
- !ruby/object:RI::MethodSummary 
  name: transaction_exclusions
- !ruby/object:RI::MethodSummary 
  name: transaction_name
- !ruby/object:RI::MethodSummary 
  name: transaction_open?
name: Simple
superclass: 
